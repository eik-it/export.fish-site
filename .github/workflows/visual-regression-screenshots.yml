name: Generate Visual Regression Screenshots
on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**'
      - 'public/**'
      - 'e2e/**'
      - 'astro.config.mjs'
      - 'tailwind.config.*'
      - 'playwright.config.ts'
jobs:
  generate-screenshots:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Fetch all history to access base branch

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install odiff and ImageMagick
        run: |
          # Install odiff via npm
          npm install -g odiff-bin

          # Install ImageMagick for cropping
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Fetch base branch screenshots for comparison
        id: fetch_base
        run: |
          # Create directory for base screenshots
          mkdir -p screenshots-base

          # Try to fetch screenshots from base branch
          BASE_REF="${{ github.base_ref }}"
          if git show "origin/${BASE_REF}:screenshots/" > /dev/null 2>&1; then
            git checkout "origin/${BASE_REF}" -- screenshots/ 2>/dev/null || true
            if [ -d "screenshots" ]; then
              mv screenshots/* screenshots-base/ 2>/dev/null || true
              echo "has_base=true" >> $GITHUB_OUTPUT
            else
              echo "has_base=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_base=false" >> $GITHUB_OUTPUT
          fi

          # Restore to PR branch state
          git checkout ${{ github.head_ref }} -- screenshots/ 2>/dev/null || true

      - name: Build Astro site
        run: npm run build

      - name: Generate visual regression screenshots
        run: npm run test:e2e:visual
        env:
          BASE_URL: http://localhost:4321

      - name: Compare screenshots and generate diffs
        if: steps.fetch_base.outputs.has_base == 'true'
        id: generate_diffs
        run: |
          mkdir -p screenshots/diffs
          DIFF_COMMENT=""
          HAS_DIFFS=false

          # Compare each screenshot
          for NEW_IMG in screenshots/*.png; do
            FILENAME=$(basename "$NEW_IMG")
            BASE_IMG="screenshots-base/$FILENAME"

            # Skip if base doesn't exist (new screenshot)
            if [ ! -f "$BASE_IMG" ]; then
              echo "New screenshot detected: $FILENAME"
              continue
            fi

            # Get dimensions of both images
            BASE_DIMS=$(identify -format "%wx%h" "$BASE_IMG")
            NEW_DIMS=$(identify -format "%wx%h" "$NEW_IMG")

            # If dimensions differ, resize to match (extend canvas with white background)
            if [ "$BASE_DIMS" != "$NEW_DIMS" ]; then
              echo "Dimension mismatch for $FILENAME: base=$BASE_DIMS new=$NEW_DIMS"

              # Get individual dimensions
              BASE_W=$(echo $BASE_DIMS | cut -d'x' -f1)
              BASE_H=$(echo $BASE_DIMS | cut -d'x' -f2)
              NEW_W=$(echo $NEW_DIMS | cut -d'x' -f1)
              NEW_H=$(echo $NEW_DIMS | cut -d'x' -f2)

              # Calculate max dimensions
              MAX_W=$((BASE_W > NEW_W ? BASE_W : NEW_W))
              MAX_H=$((BASE_H > NEW_H ? BASE_H : NEW_H))

              echo "Resizing both images to ${MAX_W}x${MAX_H}"

              # Extend canvas to max dimensions (gravity NorthWest = extend right/bottom)
              # -background white fills new areas with white
              # Use mogrify to modify files in-place
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$BASE_IMG"
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$NEW_IMG"

              # Verify dimensions after resize
              BASE_DIMS_AFTER=$(identify -format "%wx%h" "$BASE_IMG")
              NEW_DIMS_AFTER=$(identify -format "%wx%h" "$NEW_IMG")
              echo "After resize: base=$BASE_DIMS_AFTER new=$NEW_DIMS_AFTER"
            fi

            # Generate diff with odiff
            DIFF_IMG="screenshots/diffs/${FILENAME%.png}-diff.png"
            DIFF_MASK="screenshots/diffs/${FILENAME%.png}-diff-mask.png"

            # Run odiff with threshold of 0.1 (10% tolerance)
            # Exit code: 0 = identical, 22 = pixel differences, 21 = layout difference (with --fail-on-layout)
            if odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_IMG" --threshold 0.1 > /dev/null 2>&1; then
              echo "No visual changes in $FILENAME"
              rm -f "$DIFF_IMG"
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 22 ]; then
                echo "Visual changes detected in $FILENAME"
                HAS_DIFFS=true

                # Get diff lines from odiff to find Y offset of changes
                # Use parsable output and output-diff-lines to get line numbers with differences
                # Format: diffCount;diffPercentage;line1,line2,line3,...
                DIFF_OUTPUT=$(odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_MASK" --diff-mask --threshold 0.1 --antialiasing --parsable-stdout --output-diff-lines 2>&1 || true)

                echo "DEBUG: odiff parsable output (first 200 chars):"
                echo "$DIFF_OUTPUT" | head -c 200
                echo ""

                # Parse CSV format: diffCount;diffPercentage;line1,line2,line3,...
                # Extract the third field (line numbers) and get first and last
                DIFF_LINES=$(echo "$DIFF_OUTPUT" | cut -d';' -f3)
                FIRST_LINE=$(echo "$DIFF_LINES" | cut -d',' -f1)
                LAST_LINE=$(echo "$DIFF_LINES" | rev | cut -d',' -f1 | rev)

                echo "DEBUG: FIRST_LINE=$FIRST_LINE LAST_LINE=$LAST_LINE"

                # Configuration for cropping
                PADDING=50          # Vertical padding in pixels
                MIN_HEIGHT=300      # Minimum crop height

                # Get image dimensions
                IMG_WIDTH=$(identify -format "%w" "$NEW_IMG")
                IMG_HEIGHT=$(identify -format "%h" "$NEW_IMG")

                # If we couldn't parse diff lines, fall back to alpha extract method
                if [ -z "$FIRST_LINE" ] || [ ! "$FIRST_LINE" -eq "$FIRST_LINE" ] 2>/dev/null; then
                  echo "Failed to parse diff lines, falling back to alpha extract method"
                  BBOX=$(convert "$DIFF_MASK" -alpha extract -trim -format "%wx%h+%X+%Y" info:)
                  Y=$(echo $BBOX | cut -d'+' -f3)
                  HEIGHT=$(echo $BBOX | cut -d'x' -f2 | cut -d'+' -f1)
                else
                  # Calculate bounding box from diff lines
                  # Always use full width, only crop height
                  Y=$FIRST_LINE
                  HEIGHT=$((LAST_LINE - FIRST_LINE + 1))
                  echo "Calculated from diff lines: Y=$Y, HEIGHT=$HEIGHT"
                fi

                # Clean up mask after getting bounding box
                rm -f "$DIFF_MASK"

                # Apply padding and minimum height
                Y_PAD=$((Y > PADDING ? Y - PADDING : 0))
                HEIGHT_WITH_PADDING=$((HEIGHT + PADDING * 2))

                # Ensure minimum height
                if [ $HEIGHT_WITH_PADDING -lt $MIN_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$MIN_HEIGHT
                fi

                # Ensure we don't exceed image bounds
                MAX_Y=$((IMG_HEIGHT - HEIGHT_WITH_PADDING))
                if [ $Y_PAD -gt $MAX_Y ]; then
                  Y_PAD=$MAX_Y
                fi

                # If crop would exceed bottom, adjust
                CROP_BOTTOM=$((Y_PAD + HEIGHT_WITH_PADDING))
                if [ $CROP_BOTTOM -gt $IMG_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$((IMG_HEIGHT - Y_PAD))
                fi

                # Always use full width (no X cropping)
                X_PAD=0
                WIDTH_PAD=$IMG_WIDTH

                CROP_SPEC="${WIDTH_PAD}x${HEIGHT_WITH_PADDING}+${X_PAD}+${Y_PAD}"

                # Crop all three images to the change area
                BASE_CROP="screenshots/diffs/${FILENAME%.png}-base-crop.png"
                DIFF_CROP="screenshots/diffs/${FILENAME%.png}-diff-crop.png"
                NEW_CROP="screenshots/diffs/${FILENAME%.png}-new-crop.png"
                COMBINED="screenshots/diffs/${FILENAME%.png}-combined.png"

                convert "$BASE_IMG" -crop "$CROP_SPEC" +repage "$BASE_CROP"
                convert "$DIFF_IMG" -crop "$CROP_SPEC" +repage "$DIFF_CROP"
                convert "$NEW_IMG" -crop "$CROP_SPEC" +repage "$NEW_CROP"

                # Combine images horizontally: Original | Diff | New
                magick "$BASE_CROP" "$DIFF_CROP" "$NEW_CROP" +append "$COMBINED"

                echo "Created combined image: $COMBINED (${CROP_SPEC})"
              else
                echo "Error running odiff on $FILENAME (exit code: $EXIT_CODE)"
                rm -f "$DIFF_IMG"
              fi
            fi
          done

          if [ "$HAS_DIFFS" = "true" ]; then
            echo "has_diffs=true" >> $GITHUB_OUTPUT
          else
            echo "has_diffs=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for screenshot changes
        id: check_changes
        run: |
          # Check for both modified AND untracked files in screenshots/ (excluding diffs/)
          # Diffs are only for PR comments, not committed
          if [ ! -d screenshots ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          elif [ -z "$(git status --porcelain screenshots)" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate and post PR comment with visual diffs
        if: steps.generate_diffs.outputs.has_diffs == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Arrays to track images to upload
          declare -a IMAGES_TO_UPLOAD=()
          declare -a IMAGE_HASHES=()
          declare -a IMAGE_URLS=()

          # Function to get hash and URL for an image
          # Checks if image exists, queues for upload if not
          get_image_url() {
            local IMAGE_PATH="$1"

            # Calculate SHA256 hash for content-addressed storage
            local HASH=$(sha256sum "$IMAGE_PATH" | cut -d' ' -f1)
            local EXTENSION="${IMAGE_PATH##*.}"
            local FILENAME="${HASH}.${EXTENSION}"
            local URL="https://raw.githubusercontent.com/${{ github.repository }}/_ci/${FILENAME}"

            # Check if image already exists on remote
            if curl -sf -o /dev/null "$URL"; then
              echo "$URL"
              return 0
            fi

            # Queue for upload
            IMAGES_TO_UPLOAD+=("$(pwd)/${IMAGE_PATH}")
            IMAGE_HASHES+=("${FILENAME}")
            IMAGE_URLS+=("${URL}")

            echo "$URL"
          }

          # Build the comment markdown
          COMMENT="## ðŸ“¸ Visual Regression Changes Detected\n\n"

          # Process each combined diff image
          for COMBINED in screenshots/diffs/*-combined.png; do
            if [ -f "$COMBINED" ]; then
              # Extract base filename
              BASENAME=$(basename "$COMBINED" | sed 's/-combined\.png$//')

              # Get URL for combined image (queues upload if needed)
              COMBINED_URL=$(get_image_url "$COMBINED")

              # Add to comment with new table structure
              COMMENT+="<details>\n"
              COMMENT+="<summary>ðŸ“„ <strong>${BASENAME}.png</strong> (click to expand)</summary>\n\n"
              COMMENT+="<table>\n"
              COMMENT+="<tr>\n"
              COMMENT+="  <th>Original</th>\n"
              COMMENT+="  <th>Diff</th>\n"
              COMMENT+="  <th>New</th>\n"
              COMMENT+="</tr>\n"
              COMMENT+="<tr>\n"
              COMMENT+="  <td colspan=\"3\"><img src=\"${COMBINED_URL}\" alt=\"${BASENAME} comparison\"></td>\n"
              COMMENT+="</tr>\n"
              COMMENT+="</table>\n\n"
              COMMENT+="</details>\n\n"
            fi
          done

          COMMENT+="---\n\n"
          COMMENT+="*Images show full width with vertical cropping to the changed region (50px padding above/below, minimum 300px height). Full-page screenshots are available in \`screenshots/\` directory.*"

          # Upload all queued images in a single commit
          if [ ${#IMAGES_TO_UPLOAD[@]} -gt 0 ]; then
            echo "Uploading ${#IMAGES_TO_UPLOAD[@]} images to _ci branch..."

            # Create worktree
            WORKTREE_DIR="/tmp/_ci_worktree_$$"

            # Fetch or create _ci branch
            if git ls-remote --heads origin _ci | grep -q _ci; then
              git fetch origin _ci:_ci --depth=1
              git worktree add "$WORKTREE_DIR" _ci
            else
              # Create new _ci branch
              git worktree add --detach "$WORKTREE_DIR"
              cd "$WORKTREE_DIR"
              git checkout --orphan _ci
              git rm -rf . 2>/dev/null || true

              # Create README
              cat > README.md << 'EOF'
          # CI Artifacts Storage

          This branch stores content-addressed CI artifacts (visual regression diff images).

          ## Structure
          - All images stored at root level
          - Filenames: `<sha256-hash>.<extension>` (e.g., `a3dbc947...png`)
          - Automatic deduplication via content addressing

          ## Retention
          - Retention policy managed by cleanup workflow
          - See `.github/workflows/cleanup-ci-artifacts.yml` for details
          EOF

              git add README.md
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git commit -m "Initialize _ci branch for artifacts"
              git push origin _ci
              cd - >/dev/null
            fi

            # Copy all images to worktree
            cd "$WORKTREE_DIR"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            for i in "${!IMAGES_TO_UPLOAD[@]}"; do
              IMAGE_PATH="${IMAGES_TO_UPLOAD[$i]}"
              FILENAME="${IMAGE_HASHES[$i]}"
              echo "Copying ${FILENAME}..."
              cp "$IMAGE_PATH" "$FILENAME"
              git add "$FILENAME"
            done

            # Single commit for all images
            git commit -m "Add ${#IMAGES_TO_UPLOAD[@]} artifacts for PR #${{ github.event.pull_request.number }}"
            git push origin _ci
            cd - >/dev/null

            # Clean up worktree
            git worktree remove "$WORKTREE_DIR"

            echo "âœ… Uploaded ${#IMAGES_TO_UPLOAD[@]} images in single commit"
          else
            echo "All images already exist in _ci branch"
          fi

          # Wait for GitHub CDN to propagate the uploaded images
          # This prevents broken image links in the PR comment
          echo "Waiting 5 seconds for CDN propagation..."
          sleep 5

          # Post comment to PR (use printf to interpret escape sequences)
          printf "%b" "$COMMENT" | gh pr comment ${{ github.event.pull_request.number }} --body-file -

      - name: Commit and push screenshots
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Clean up any worktree remnants and ensure clean state
          git worktree prune
          git branch -D _ci 2>/dev/null || true

          # Remove diffs directory - these are only for PR comments, never committed
          rm -rf screenshots/diffs/

          # Stash any uncommitted changes (screenshots)
          git stash push -u screenshots/

          # Fetch and rebase to latest
          git fetch origin ${{ github.head_ref }}
          git rebase origin/${{ github.head_ref }}

          # Restore screenshots
          git stash pop

          # Get the original commit message and author from current HEAD
          ORIGINAL_MSG=$(git log -1 --pretty=%B)
          ORIGINAL_AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")

          # Stage screenshot changes
          git add screenshots/

          # Amend the existing commit with screenshots
          git commit --amend --no-edit --author="$ORIGINAL_AUTHOR"

          # Force push with lease
          git push --force-with-lease origin ${{ github.head_ref }}

      - name: Confirm PR commit
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo 'âœ… Visual regression screenshots have been automatically generated and committed to this PR.'

      - name: No changes needed
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo 'âœ… Visual regression screenshots are up to date. No changes needed.'
