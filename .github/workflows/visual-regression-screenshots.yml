name: Generate Visual Regression Screenshots
on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**'
      - 'public/**'
      - 'e2e/**'
      - 'astro.config.mjs'
      - 'tailwind.config.*'
      - 'playwright.config.ts'
jobs:
  generate-screenshots:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Fetch all history to access base branch

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install odiff and ImageMagick
        run: |
          # Install odiff via npm
          npm install -g odiff-bin

          # Install ImageMagick for cropping
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Fetch base branch screenshots for comparison
        id: fetch_base
        run: |
          # Create directory for base screenshots
          mkdir -p screenshots-base

          # Try to fetch screenshots from base branch
          BASE_REF="${{ github.base_ref }}"
          if git show "origin/${BASE_REF}:screenshots/" > /dev/null 2>&1; then
            git checkout "origin/${BASE_REF}" -- screenshots/ 2>/dev/null || true
            if [ -d "screenshots" ]; then
              mv screenshots/* screenshots-base/ 2>/dev/null || true
              echo "has_base=true" >> $GITHUB_OUTPUT
            else
              echo "has_base=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_base=false" >> $GITHUB_OUTPUT
          fi

          # Restore to PR branch state
          git checkout ${{ github.head_ref }} -- screenshots/ 2>/dev/null || true

      - name: Build Astro site
        run: npm run build

      - name: Generate visual regression screenshots
        run: npm run test:e2e:visual
        env:
          BASE_URL: http://localhost:4321

      - name: Compare screenshots and generate diffs
        if: steps.fetch_base.outputs.has_base == 'true'
        id: generate_diffs
        run: |
          mkdir -p screenshots/diffs
          DIFF_COMMENT=""
          HAS_DIFFS=false

          # Compare each screenshot
          for NEW_IMG in screenshots/*.png; do
            FILENAME=$(basename "$NEW_IMG")
            BASE_IMG="screenshots-base/$FILENAME"

            # Skip if base doesn't exist (new screenshot)
            if [ ! -f "$BASE_IMG" ]; then
              echo "New screenshot detected: $FILENAME"
              continue
            fi

            # Get dimensions of both images
            BASE_DIMS=$(identify -format "%wx%h" "$BASE_IMG")
            NEW_DIMS=$(identify -format "%wx%h" "$NEW_IMG")

            # If dimensions differ, resize to match (extend canvas with white background)
            if [ "$BASE_DIMS" != "$NEW_DIMS" ]; then
              echo "Dimension mismatch for $FILENAME: base=$BASE_DIMS new=$NEW_DIMS"

              # Get individual dimensions
              BASE_W=$(echo $BASE_DIMS | cut -d'x' -f1)
              BASE_H=$(echo $BASE_DIMS | cut -d'x' -f2)
              NEW_W=$(echo $NEW_DIMS | cut -d'x' -f1)
              NEW_H=$(echo $NEW_DIMS | cut -d'x' -f2)

              # Calculate max dimensions
              MAX_W=$((BASE_W > NEW_W ? BASE_W : NEW_W))
              MAX_H=$((BASE_H > NEW_H ? BASE_H : NEW_H))

              echo "Resizing both images to ${MAX_W}x${MAX_H}"

              # Extend canvas to max dimensions (gravity NorthWest = extend right/bottom)
              # -background white fills new areas with white
              # Use mogrify to modify files in-place
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$BASE_IMG"
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$NEW_IMG"

              # Verify dimensions after resize
              BASE_DIMS_AFTER=$(identify -format "%wx%h" "$BASE_IMG")
              NEW_DIMS_AFTER=$(identify -format "%wx%h" "$NEW_IMG")
              echo "After resize: base=$BASE_DIMS_AFTER new=$NEW_DIMS_AFTER"
            fi

            # Generate diff with odiff
            DIFF_IMG="screenshots/diffs/${FILENAME%.png}-diff.png"
            DIFF_MASK="screenshots/diffs/${FILENAME%.png}-diff-mask.png"

            # Run odiff with threshold of 0.1 (10% tolerance)
            # Exit code: 0 = identical, 22 = pixel differences, 21 = layout difference (with --fail-on-layout)
            if odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_IMG" --threshold 0.1 > /dev/null 2>&1; then
              echo "No visual changes in $FILENAME"
              rm -f "$DIFF_IMG"
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 22 ]; then
                echo "Visual changes detected in $FILENAME"
                HAS_DIFFS=true

                # Get diff lines from odiff to find Y offset of changes
                # Use parsable output and output-diff-lines to get line numbers with differences
                # Format: diffCount;diffPercentage;line1,line2,line3,...
                DIFF_OUTPUT=$(odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_MASK" --diff-mask --threshold 0.1 --antialiasing --parsable-stdout --output-diff-lines 2>&1 || true)

                echo "DEBUG: odiff parsable output (first 200 chars):"
                echo "$DIFF_OUTPUT" | head -c 200
                echo ""

                # Parse CSV format: diffCount;diffPercentage;line1,line2,line3,...
                # Extract the third field (line numbers) and get first and last
                DIFF_LINES=$(echo "$DIFF_OUTPUT" | cut -d';' -f3)
                FIRST_LINE=$(echo "$DIFF_LINES" | cut -d',' -f1)
                LAST_LINE=$(echo "$DIFF_LINES" | rev | cut -d',' -f1 | rev)

                echo "DEBUG: FIRST_LINE=$FIRST_LINE LAST_LINE=$LAST_LINE"

                # Configuration for cropping
                PADDING=50          # Vertical padding in pixels
                MIN_HEIGHT=300      # Minimum crop height

                # Get image dimensions
                IMG_WIDTH=$(identify -format "%w" "$NEW_IMG")
                IMG_HEIGHT=$(identify -format "%h" "$NEW_IMG")

                # If we couldn't parse diff lines, fall back to alpha extract method
                if [ -z "$FIRST_LINE" ] || [ ! "$FIRST_LINE" -eq "$FIRST_LINE" ] 2>/dev/null; then
                  echo "Failed to parse diff lines, falling back to alpha extract method"
                  BBOX=$(convert "$DIFF_MASK" -alpha extract -trim -format "%wx%h+%X+%Y" info:)
                  Y=$(echo $BBOX | cut -d'+' -f3)
                  HEIGHT=$(echo $BBOX | cut -d'x' -f2 | cut -d'+' -f1)
                else
                  # Calculate bounding box from diff lines
                  # Always use full width, only crop height
                  Y=$FIRST_LINE
                  HEIGHT=$((LAST_LINE - FIRST_LINE + 1))
                  echo "Calculated from diff lines: Y=$Y, HEIGHT=$HEIGHT"
                fi

                # Clean up mask after getting bounding box
                rm -f "$DIFF_MASK"

                # Apply padding and minimum height
                Y_PAD=$((Y > PADDING ? Y - PADDING : 0))
                HEIGHT_WITH_PADDING=$((HEIGHT + PADDING * 2))

                # Ensure minimum height
                if [ $HEIGHT_WITH_PADDING -lt $MIN_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$MIN_HEIGHT
                fi

                # Ensure we don't exceed image bounds
                MAX_Y=$((IMG_HEIGHT - HEIGHT_WITH_PADDING))
                if [ $Y_PAD -gt $MAX_Y ]; then
                  Y_PAD=$MAX_Y
                fi

                # If crop would exceed bottom, adjust
                CROP_BOTTOM=$((Y_PAD + HEIGHT_WITH_PADDING))
                if [ $CROP_BOTTOM -gt $IMG_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$((IMG_HEIGHT - Y_PAD))
                fi

                # Always use full width (no X cropping)
                X_PAD=0
                WIDTH_PAD=$IMG_WIDTH

                CROP_SPEC="${WIDTH_PAD}x${HEIGHT_WITH_PADDING}+${X_PAD}+${Y_PAD}"

                # Crop all three images to the change area
                BASE_CROP="screenshots/diffs/${FILENAME%.png}-base-crop.png"
                NEW_CROP="screenshots/diffs/${FILENAME%.png}-new-crop.png"
                DIFF_CROP="screenshots/diffs/${FILENAME%.png}-diff-crop.png"

                convert "$BASE_IMG" -crop "$CROP_SPEC" +repage "$BASE_CROP"
                convert "$NEW_IMG" -crop "$CROP_SPEC" +repage "$NEW_CROP"
                convert "$DIFF_IMG" -crop "$CROP_SPEC" +repage "$DIFF_CROP"

                # Keep the full diff too for reference
                echo "Cropped changes in $FILENAME to $CROP_SPEC"
              else
                echo "Error running odiff on $FILENAME (exit code: $EXIT_CODE)"
                rm -f "$DIFF_IMG"
              fi
            fi
          done

          if [ "$HAS_DIFFS" = "true" ]; then
            echo "has_diffs=true" >> $GITHUB_OUTPUT
          else
            echo "has_diffs=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for screenshot changes
        id: check_changes
        run: |
          # Check for both modified AND untracked files in screenshots/ (excluding diffs/)
          # Diffs are only for PR comments, not committed
          if [ ! -d screenshots ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          elif [ -z "$(git status --porcelain screenshots)" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate and post PR comment with visual diffs
        if: steps.generate_diffs.outputs.has_diffs == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Function to upload image to _ci branch with content-addressed storage
          # Uses git worktree to completely isolate _ci branch operations from PR branch
          upload_image() {
            local IMAGE_PATH="$1"

            echo ">>> Uploading: $IMAGE_PATH" >&2

            # Calculate SHA256 hash of the image for content-addressed storage (deduplication)
            local HASH=$(sha256sum "$IMAGE_PATH" | cut -d' ' -f1)
            local EXTENSION="${IMAGE_PATH##*.}"
            local FILENAME="${HASH}.${EXTENSION}"

            echo ">>> Hash: $HASH, Filename: $FILENAME" >&2

            # Check if image already exists on remote (avoid unnecessary uploads)
            if curl -sf -o /dev/null "https://raw.githubusercontent.com/${{ github.repository }}/_ci/${FILENAME}"; then
              echo ">>> Image already exists on remote: ${FILENAME}" >&2
              echo "https://raw.githubusercontent.com/${{ github.repository }}/_ci/${FILENAME}"
              return 0
            fi

            echo ">>> Image not found on remote, uploading..." >&2

            # Use absolute path for image
            local ABSOLUTE_IMAGE_PATH="$(pwd)/${IMAGE_PATH}"

            # Create worktree for _ci branch in /tmp (completely isolated from PR branch)
            local WORKTREE_DIR="/tmp/_ci_worktree_$$"
            echo ">>> Creating worktree at: $WORKTREE_DIR" >&2

            # Fetch _ci branch or create it if it doesn't exist
            if git ls-remote --heads origin _ci | grep -q _ci; then
              echo ">>> _ci branch exists on remote, fetching..." >&2
              git fetch origin _ci:_ci --depth=1 >&2
              git worktree add "$WORKTREE_DIR" _ci >&2
            else
              echo ">>> Creating new _ci branch..." >&2
              # Create orphan branch in worktree
              git worktree add --detach "$WORKTREE_DIR" >&2
              cd "$WORKTREE_DIR"
              git checkout --orphan _ci >&2
              git rm -rf . 2>/dev/null || true

              # Create README
              echo "# CI Artifacts Storage" > README.md
              echo "" >> README.md
              echo "This branch stores content-addressed CI artifacts (visual regression diff images)." >> README.md
              echo "" >> README.md
              echo "## Structure" >> README.md
              echo "- All images stored at root level" >> README.md
              echo "- Filenames: \`<sha256-hash>.<extension>\` (e.g., \`a3dbc947...png\`)" >> README.md
              echo "- Automatic deduplication via content addressing" >> README.md
              echo "" >> README.md
              echo "## Retention" >> README.md
              echo "- Images referenced in open PRs: Kept indefinitely" >> README.md
              echo "- Images from closed PRs: Kept for 7 days" >> README.md
              echo "- Unreferenced images: Kept for 90 days" >> README.md
              echo "" >> README.md
              echo "## Cleanup" >> README.md
              echo "Automated cleanup runs weekly via \`.github/workflows/cleanup-ci-artifacts.yml\`" >> README.md

              git add README.md >&2
              git config user.name "github-actions[bot]" >&2
              git config user.email "github-actions[bot]@users.noreply.github.com" >&2
              git commit -m "Initialize _ci branch for artifacts" >&2
              git push origin _ci >&2
              cd - >/dev/null
            fi

            # Copy image to worktree and commit
            echo ">>> Copying image to worktree..." >&2
            cp "$ABSOLUTE_IMAGE_PATH" "$WORKTREE_DIR/${FILENAME}"

            cd "$WORKTREE_DIR"
            git config user.name "github-actions[bot]" >&2
            git config user.email "github-actions[bot]@users.noreply.github.com" >&2
            git add "${FILENAME}" >&2
            git commit -m "Add artifact ${FILENAME} for PR #${{ github.event.pull_request.number }}" >&2
            git push origin _ci >&2
            cd - >/dev/null

            # Clean up worktree
            echo ">>> Cleaning up worktree..." >&2
            git worktree remove "$WORKTREE_DIR" >&2

            # Return the raw.githubusercontent.com URL
            local URL="https://raw.githubusercontent.com/${{ github.repository }}/_ci/${FILENAME}"
            echo ">>> Upload complete: $URL" >&2
            echo "$URL"
          }

          # Build the comment markdown
          COMMENT="## ðŸ“¸ Visual Regression Changes Detected\n\n"

          # Process each diff
          for DIFF_CROP in screenshots/diffs/*-diff-crop.png; do
            if [ -f "$DIFF_CROP" ]; then
              # Extract base filename
              BASENAME=$(basename "$DIFF_CROP" | sed 's/-diff-crop\.png$//')

              # Upload cropped images to _ci branch and get URLs
              BASE_CROP="screenshots/diffs/${BASENAME}-base-crop.png"
              NEW_CROP="screenshots/diffs/${BASENAME}-new-crop.png"

              BASE_CROP_URL=$(upload_image "$BASE_CROP")
              NEW_CROP_URL=$(upload_image "$NEW_CROP")
              DIFF_CROP_URL=$(upload_image "$DIFF_CROP")

              # Add to comment (use HTML table for better control over alignment)
              COMMENT+="<details>\n"
              COMMENT+="<summary>ðŸ“„ <strong>${BASENAME}.png</strong> (click to expand)</summary>\n\n"
              COMMENT+="<table>\n"
              COMMENT+="<tr>\n"
              COMMENT+="  <th>Original</th>\n"
              COMMENT+="  <th>New</th>\n"
              COMMENT+="  <th>Diff</th>\n"
              COMMENT+="</tr>\n"
              COMMENT+="<tr>\n"
              COMMENT+="  <td valign=\"top\"><img src=\"${BASE_CROP_URL}\" alt=\"original\"></td>\n"
              COMMENT+="  <td valign=\"top\"><img src=\"${NEW_CROP_URL}\" alt=\"new\"></td>\n"
              COMMENT+="  <td valign=\"top\"><img src=\"${DIFF_CROP_URL}\" alt=\"diff\"></td>\n"
              COMMENT+="</tr>\n"
              COMMENT+="</table>\n\n"
              COMMENT+="</details>\n\n"
            fi
          done

          COMMENT+="---\n\n"
          COMMENT+="*Images show full width with vertical cropping to the changed region (50px padding above/below, minimum 300px height). Full-page screenshots are available in \`screenshots/\` directory.*"

          # Post comment to PR (use printf to interpret escape sequences)
          printf "%b" "$COMMENT" | gh pr comment ${{ github.event.pull_request.number }} --body-file -

      - name: Commit and push screenshots
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Clean up any worktree remnants and ensure clean state
          git worktree prune
          git branch -D _ci 2>/dev/null || true

          # Remove diffs directory - these are only for PR comments, never committed
          rm -rf screenshots/diffs/

          # Stash any uncommitted changes (screenshots)
          git stash push -u screenshots/

          # Fetch and rebase to latest
          git fetch origin ${{ github.head_ref }}
          git rebase origin/${{ github.head_ref }}

          # Restore screenshots
          git stash pop

          # Get the original commit message and author from current HEAD
          ORIGINAL_MSG=$(git log -1 --pretty=%B)
          ORIGINAL_AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")

          # Stage screenshot changes
          git add screenshots/

          # Amend the existing commit with screenshots
          git commit --amend --no-edit --author="$ORIGINAL_AUTHOR"

          # Force push with lease
          git push --force-with-lease origin ${{ github.head_ref }}

      - name: Confirm PR commit
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo 'âœ… Visual regression screenshots have been automatically generated and committed to this PR.'

      - name: No changes needed
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo 'âœ… Visual regression screenshots are up to date. No changes needed.'
