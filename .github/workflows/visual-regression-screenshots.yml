name: Generate Visual Regression Screenshots
on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**'
      - 'public/**'
      - 'e2e/**'
      - 'astro.config.mjs'
      - 'tailwind.config.*'
      - 'playwright.config.ts'
jobs:
  generate-screenshots:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Fetch all history to access base branch

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install odiff and ImageMagick
        run: |
          # Install odiff via npm
          npm install -g odiff-bin

          # Install ImageMagick for cropping
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Fetch base branch screenshots for comparison
        id: fetch_base
        run: |
          # Create directory for base screenshots
          mkdir -p screenshots-base

          # Try to fetch screenshots from base branch
          BASE_REF="${{ github.base_ref }}"
          if git show "origin/${BASE_REF}:screenshots/" > /dev/null 2>&1; then
            git checkout "origin/${BASE_REF}" -- screenshots/ 2>/dev/null || true
            if [ -d "screenshots" ]; then
              mv screenshots/* screenshots-base/ 2>/dev/null || true
              echo "has_base=true" >> $GITHUB_OUTPUT
            else
              echo "has_base=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_base=false" >> $GITHUB_OUTPUT
          fi

          # Restore to PR branch state
          git checkout ${{ github.head_ref }} -- screenshots/ 2>/dev/null || true

      - name: Build Astro site
        run: npm run build

      - name: Generate visual regression screenshots
        run: npm run test:e2e:visual
        env:
          BASE_URL: http://localhost:4321

      - name: Compare screenshots and generate diffs
        if: steps.fetch_base.outputs.has_base == 'true'
        id: generate_diffs
        run: |
          mkdir -p screenshots/diffs
          DIFF_COMMENT=""
          HAS_DIFFS=false

          # Compare each screenshot
          for NEW_IMG in screenshots/*.png; do
            FILENAME=$(basename "$NEW_IMG")
            BASE_IMG="screenshots-base/$FILENAME"

            # Skip if base doesn't exist (new screenshot)
            if [ ! -f "$BASE_IMG" ]; then
              echo "New screenshot detected: $FILENAME"
              continue
            fi

            # Get dimensions of both images
            BASE_DIMS=$(identify -format "%wx%h" "$BASE_IMG")
            NEW_DIMS=$(identify -format "%wx%h" "$NEW_IMG")

            # If dimensions differ, resize to match (extend canvas with white background)
            if [ "$BASE_DIMS" != "$NEW_DIMS" ]; then
              echo "Dimension mismatch for $FILENAME: base=$BASE_DIMS new=$NEW_DIMS"

              # Get individual dimensions
              BASE_W=$(echo $BASE_DIMS | cut -d'x' -f1)
              BASE_H=$(echo $BASE_DIMS | cut -d'x' -f2)
              NEW_W=$(echo $NEW_DIMS | cut -d'x' -f1)
              NEW_H=$(echo $NEW_DIMS | cut -d'x' -f2)

              # Calculate max dimensions
              MAX_W=$((BASE_W > NEW_W ? BASE_W : NEW_W))
              MAX_H=$((BASE_H > NEW_H ? BASE_H : NEW_H))

              echo "Resizing both images to ${MAX_W}x${MAX_H}"

              # Extend canvas to max dimensions (gravity NorthWest = extend right/bottom)
              # -background white fills new areas with white
              # Use mogrify to modify files in-place
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$BASE_IMG"
              mogrify -background white -gravity NorthWest -extent "${MAX_W}x${MAX_H}" "$NEW_IMG"

              # Verify dimensions after resize
              BASE_DIMS_AFTER=$(identify -format "%wx%h" "$BASE_IMG")
              NEW_DIMS_AFTER=$(identify -format "%wx%h" "$NEW_IMG")
              echo "After resize: base=$BASE_DIMS_AFTER new=$NEW_DIMS_AFTER"
            fi

            # Generate diff with odiff
            DIFF_IMG="screenshots/diffs/${FILENAME%.png}-diff.png"
            DIFF_MASK="screenshots/diffs/${FILENAME%.png}-diff-mask.png"

            # Run odiff with threshold of 0.1 (10% tolerance)
            # Exit code: 0 = identical, 22 = pixel differences, 21 = layout difference (with --fail-on-layout)
            if odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_IMG" --threshold 0.1 > /dev/null 2>&1; then
              echo "No visual changes in $FILENAME"
              rm -f "$DIFF_IMG"
            else
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 22 ]; then
                echo "Visual changes detected in $FILENAME"
                HAS_DIFFS=true

                # Get diff lines from odiff to find Y offset of changes
                # Use parsable output and output-diff-lines to get line numbers with differences
                # Format: diffCount;diffPercentage;line1,line2,line3,...
                DIFF_OUTPUT=$(odiff "$BASE_IMG" "$NEW_IMG" "$DIFF_MASK" --diff-mask --threshold 0.1 --antialiasing --parsable-stdout --output-diff-lines 2>&1 || true)

                echo "DEBUG: odiff parsable output (first 200 chars):"
                echo "$DIFF_OUTPUT" | head -c 200
                echo ""

                # Parse CSV format: diffCount;diffPercentage;line1,line2,line3,...
                # Extract the third field (line numbers) and get first and last
                DIFF_LINES=$(echo "$DIFF_OUTPUT" | cut -d';' -f3)
                FIRST_LINE=$(echo "$DIFF_LINES" | cut -d',' -f1)
                LAST_LINE=$(echo "$DIFF_LINES" | rev | cut -d',' -f1 | rev)

                echo "DEBUG: FIRST_LINE=$FIRST_LINE LAST_LINE=$LAST_LINE"

                # Configuration for cropping
                PADDING=50          # Vertical padding in pixels
                MIN_HEIGHT=300      # Minimum crop height

                # Get image dimensions
                IMG_WIDTH=$(identify -format "%w" "$NEW_IMG")
                IMG_HEIGHT=$(identify -format "%h" "$NEW_IMG")

                # If we couldn't parse diff lines, fall back to alpha extract method
                if [ -z "$FIRST_LINE" ] || [ ! "$FIRST_LINE" -eq "$FIRST_LINE" ] 2>/dev/null; then
                  echo "Failed to parse diff lines, falling back to alpha extract method"
                  BBOX=$(convert "$DIFF_MASK" -alpha extract -trim -format "%wx%h+%X+%Y" info:)
                  Y=$(echo $BBOX | cut -d'+' -f3)
                  HEIGHT=$(echo $BBOX | cut -d'x' -f2 | cut -d'+' -f1)
                else
                  # Calculate bounding box from diff lines
                  # Always use full width, only crop height
                  Y=$FIRST_LINE
                  HEIGHT=$((LAST_LINE - FIRST_LINE + 1))
                  echo "Calculated from diff lines: Y=$Y, HEIGHT=$HEIGHT"
                fi

                # Clean up mask after getting bounding box
                rm -f "$DIFF_MASK"

                # Apply padding and minimum height
                Y_PAD=$((Y > PADDING ? Y - PADDING : 0))
                HEIGHT_WITH_PADDING=$((HEIGHT + PADDING * 2))

                # Ensure minimum height
                if [ $HEIGHT_WITH_PADDING -lt $MIN_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$MIN_HEIGHT
                fi

                # Ensure we don't exceed image bounds
                MAX_Y=$((IMG_HEIGHT - HEIGHT_WITH_PADDING))
                if [ $Y_PAD -gt $MAX_Y ]; then
                  Y_PAD=$MAX_Y
                fi

                # If crop would exceed bottom, adjust
                CROP_BOTTOM=$((Y_PAD + HEIGHT_WITH_PADDING))
                if [ $CROP_BOTTOM -gt $IMG_HEIGHT ]; then
                  HEIGHT_WITH_PADDING=$((IMG_HEIGHT - Y_PAD))
                fi

                # Always use full width (no X cropping)
                X_PAD=0
                WIDTH_PAD=$IMG_WIDTH

                CROP_SPEC="${WIDTH_PAD}x${HEIGHT_WITH_PADDING}+${X_PAD}+${Y_PAD}"

                # Crop all three images to the change area
                BASE_CROP="screenshots/diffs/${FILENAME%.png}-base-crop.png"
                NEW_CROP="screenshots/diffs/${FILENAME%.png}-new-crop.png"
                DIFF_CROP="screenshots/diffs/${FILENAME%.png}-diff-crop.png"

                convert "$BASE_IMG" -crop "$CROP_SPEC" +repage "$BASE_CROP"
                convert "$NEW_IMG" -crop "$CROP_SPEC" +repage "$NEW_CROP"
                convert "$DIFF_IMG" -crop "$CROP_SPEC" +repage "$DIFF_CROP"

                # Keep the full diff too for reference
                echo "Cropped changes in $FILENAME to $CROP_SPEC"
              else
                echo "Error running odiff on $FILENAME (exit code: $EXIT_CODE)"
                rm -f "$DIFF_IMG"
              fi
            fi
          done

          if [ "$HAS_DIFFS" = "true" ]; then
            echo "has_diffs=true" >> $GITHUB_OUTPUT
          else
            echo "has_diffs=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for screenshot changes
        id: check_changes
        run: |
          # Check for both modified AND untracked files in screenshots/ (excluding diffs/)
          # Diffs are only for PR comments, not committed
          if [ -z "$(git status --porcelain screenshots/*.png)" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push screenshots
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Remove diffs directory - diffs are only for PR comments, never committed
          rm -rf screenshots/diffs/

          # Get the original commit message and author to preserve them
          ORIGINAL_MSG=$(git log -1 --pretty=%B)
          ORIGINAL_AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")

          # Stage only base screenshot changes (no diffs directory)
          git add screenshots/*.png

          # Amend the existing commit, preserving original message and author
          git commit --amend --no-edit --author="$ORIGINAL_AUTHOR"

          # Safety check: Verify remote hasn't changed before force push
          git fetch origin ${{ github.head_ref }}
          REMOTE_HASH=$(git rev-parse origin/${{ github.head_ref }})
          LOCAL_BASE=$(git rev-parse HEAD~1)

          if [ "$REMOTE_HASH" != "$LOCAL_BASE" ]; then
            echo "‚ö†Ô∏è  Remote branch has new commits. Rebasing..."
            echo "Remote: $REMOTE_HASH"
            echo "Expected: $LOCAL_BASE"

            # Reset to pre-amend state and unstage screenshots
            git reset --soft HEAD~1
            git reset HEAD screenshots/

            # Stash the screenshots temporarily
            git stash push -u screenshots/

            # Pull latest changes with rebase
            git pull --rebase origin ${{ github.head_ref }}

            # Restore the screenshots
            git stash pop

            # Get the new commit info after rebase
            ORIGINAL_MSG=$(git log -1 --pretty=%B)
            ORIGINAL_AUTHOR=$(git log -1 --pretty=format:"%an <%ae>")

            # Re-stage and re-amend with screenshots
            git add screenshots/*.png
            git commit --amend --no-edit --author="$ORIGINAL_AUTHOR"

            echo "‚úÖ Rebased successfully"
          fi

          # Force push with lease after verification/rebase
          git push --force-with-lease

      - name: Generate and post PR comment with visual diffs
        if: steps.generate_diffs.outputs.has_diffs == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Helper function to upload image to GitHub and get URL
          upload_image() {
            local IMAGE_PATH="$1"
            local IMAGE_NAME=$(basename "$IMAGE_PATH")

            # Upload image to GitHub's asset server using the REST API
            # The API endpoint for uploading assets is specific to issues/PRs
            local RESPONSE=$(curl -sS -X POST \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/octet-stream" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              --data-binary @"$IMAGE_PATH" \
              "https://uploads.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/assets?name=${IMAGE_NAME}")

            # Debug: show response
            echo "Upload response for $IMAGE_NAME:" >&2
            echo "$RESPONSE" >&2

            # Extract URL from JSON response - GitHub returns the asset URL in the "url" field
            echo "$RESPONSE" | jq -r '.url // empty'
          }

          # Build the comment markdown header
          COMMENT="## üì∏ Visual Regression Changes Detected\n\n"
          COMMENT+="The following screenshots show visual differences compared to the base branch.\n\n"
          COMMENT+="**Legend:**\n"
          COMMENT+="- **Original**: Screenshot from base branch (\`${{ github.base_ref }}\`)\n"
          COMMENT+="- **New**: Screenshot from this PR\n"
          COMMENT+="- **Diff**: Visual difference highlighted (cropped to changed area)\n\n"
          COMMENT+="---\n\n"

          # Process each diff and upload images
          for DIFF_CROP in screenshots/diffs/*-diff-crop.png; do
            if [ -f "$DIFF_CROP" ]; then
              # Extract base filename
              BASENAME=$(basename "$DIFF_CROP" | sed 's/-diff-crop\.png$//')

              # Get corresponding images
              BASE_CROP="screenshots/diffs/${BASENAME}-base-crop.png"
              NEW_CROP="screenshots/diffs/${BASENAME}-new-crop.png"

              echo "Uploading images for $BASENAME..."

              # Upload images and get URLs
              BASE_CROP_URL=$(upload_image "$BASE_CROP")
              NEW_CROP_URL=$(upload_image "$NEW_CROP")
              DIFF_CROP_URL=$(upload_image "$DIFF_CROP")

              echo "  Base: $BASE_CROP_URL"
              echo "  New: $NEW_CROP_URL"
              echo "  Diff: $DIFF_CROP_URL"

              # Add to comment
              COMMENT+="<details>\n"
              COMMENT+="<summary>üìÑ <strong>${BASENAME}.png</strong> (click to expand)</summary>\n\n"
              COMMENT+="| Original | New | Diff |\n"
              COMMENT+="|----------|-----|------|\n"
              COMMENT+="| ![original](${BASE_CROP_URL}) | ![new](${NEW_CROP_URL}) | ![diff](${DIFF_CROP_URL}) |\n\n"
              COMMENT+="</details>\n\n"
            fi
          done

          COMMENT+="---\n\n"
          COMMENT+="*Images show only the changed region with 50px padding. Full screenshots are available in \`screenshots/\` directory.*"

          # Post comment to PR
          echo -e "$COMMENT" | gh pr comment ${{ github.event.pull_request.number }} --body-file -
      - name: Confirm PR commit
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo '‚úÖ Visual regression screenshots have been automatically generated and committed to this PR.'

      - name: No changes needed
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo '‚úÖ Visual regression screenshots are up to date. No changes needed.'
